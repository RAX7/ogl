<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
        <meta
            name="viewport"
            content="width=device-width, minimal-ui, viewport-fit=cover, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"
        />
        <link rel="icon" type="image/png" href="assets/favicon.png" />

        <title>OGL â€¢ Performance - High mesh count</title>
        <link href="assets/main.css" rel="stylesheet" />
    </head>
    <body style="display: flex; flex-direction: column; align-items: flex-end">
        <div class="Info">Performance - High mesh count</div>
        <div class="Info" style="padding-top: 0">
            <input id="meshCountInput" style="width: 100px" />
            <button
                id="meshCountButton"
                style="padding: 2px; border: 1px solid #000; background-color: #fff"
                onclick="setMeshCount(document.getElementById('meshCountInput').value)"
            >
                Set mesh count
            </button>
        </div>

        <script src="//mrdoob.github.io/stats.js/build/stats.min.js"></script>
        <script>
            window.__stats = new Stats();
            document.body.appendChild(window.__stats.dom);
        </script>

        <script type="module">
            import { Renderer, Camera, Transform, Program, Mesh, Box } from '../src/index.mjs';

            const useUBO = true;

            const vertex100 = /* glsl */ `
                attribute vec3 position;
                attribute vec3 normal;
    
                uniform mat4 modelViewMatrix;
                uniform mat4 projectionMatrix;
                uniform mat3 normalMatrix;
    
                varying vec3 vNormal;
    
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;

            const fragment100 = /* glsl */ `
                precision highp float;
    
                varying vec3 vNormal;
    
                void main() {
                    vec3 normal = normalize(vNormal);
                    float lighting = dot(normal, normalize(vec3(-0.3, 0.8, 0.6)));
                    gl_FragColor.rgb = vec3(0.2, 0.8, 1.0) + lighting * 0.1;
                    gl_FragColor.a = 1.0;
                }
            `;

            const vertex300 = /* glsl */ `#version 300 es
                in vec3 position;
                in vec3 normal;

                // THIS IS CALLED A UNIFORM BLOCK
                uniform Camera {
                    mat4 projectionMatrix;
                    mat4 viewMatrix;
                    vec3 cameraPosition;
                };

                uniform Model {
                    mat4 modelMatrix;
                    mat4 modelViewMatrix;
                    mat3 normalMatrix;
                };
    
                out vec3 vNormal;
    
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;

            const fragment300 = /* glsl */ `#version 300 es
                precision highp float;
    
                in vec3 vNormal;
                out vec4 FragColor;
    
                void main() {
                    vec3 normal = normalize(vNormal);
                    float lighting = dot(normal, normalize(vec3(-0.3, 0.8, 0.6)));
                    FragColor.rgb = vec3(0.2, 0.8, 1.0) + lighting * 0.1;
                    FragColor.a = 1.0;
                }
            `;

            {
                const renderer = new Renderer();
                const gl = renderer.gl;
                document.body.appendChild(gl.canvas);
                gl.clearColor(1, 1, 1, 1);

                console.log(renderer);

                const camera = new Camera(gl, { fov: 35, far: 3000 });

                function resize() {
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    camera.perspective({ aspect: gl.canvas.width / gl.canvas.height });
                }
                window.addEventListener('resize', resize, false);
                resize();

                const scene = new Transform();

                // Create base geometry
                const cubeGeometry = new Box(gl);

                const programs = [];
                for (let i = 0; i < 12; i++) {
                    // Using the shader from the base primitive example
                    const vertex = useUBO ? vertex300 : vertex100;
                    const fragment = useUBO ? fragment300 : fragment100;
                    const program = new Program(gl, { vertex, fragment });
                    programs.push(program);
                }

                // mesh container
                let meshes = [];

                window.setMeshCount = function setMeshCount(count) {
                    // sanitize input
                    count = parseInt(count) || 1000;

                    // remove old meshes
                    for (let i = 0; i < meshes.length; ++i) scene.removeChild(meshes[i]);
                    meshes = [];

                    // create our meshes according to input
                    for (let i = 0; i < count; ++i) {
                        const program = programs[i % programs.length];
                        let mesh = new Mesh(gl, { geometry: cubeGeometry, program });

                        // position meshes in a random position between -100 / +100 in each dimension
                        mesh.position.set(-100 + Math.random() * 200, -100 + Math.random() * 200, -100 + Math.random() * 200);
                        mesh.rotation.set(Math.random() * 3, Math.random() * 3, Math.random() * 3);
                        scene.addChild(mesh);
                        meshes.push(mesh);
                    }

                    // set input counter value to make sure
                    document.getElementById('meshCountInput').value = count;
                };

                setMeshCount(5_000);

                let updateCamera = true;
                requestAnimationFrame(update);
                function update() {
                    window.__stats.begin();
                    
                    // rotate camera
                    let time = performance.now() / 30000;
                    camera.position.set(Math.sin(time) * 180, 80, Math.cos(time) * 180);
                    camera.lookAt([0, 0, 0]);

                    // rotate meshes
                    for (let i = 0; i < meshes.length; ++i) {
                        meshes[i].rotation.x += 0.01;
                        meshes[i].rotation.y += 0.01;
                    }

                    renderer.render({ scene, camera }, updateCamera);

                    window.__stats.end();
                    requestAnimationFrame(update);
                }
            }
        </script>
    </body>
</html>
